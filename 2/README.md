# 2. 시작하기

  

## 2.1 삽입 정렬

  

입력 : `n개 수들의 수열`  <a1, a2, ....., an>

  

출력 : `a'1 <= a'2 <= ... <= a'n을 만족하는 입력 순열`(재배치)

  

의사코드는 일반적으로 소프트웨어 공학 관점의 문제를 고려하지 않는다.

그래서 데이터 추상화, 모듈화, 오류 처리 등의 문제가 종종 무시되는데, 이는 알고리즘의 본질을 좀 더 간결하고 분명하게 전달하기 위해서다.

  

```

INSERTION_SORT( A )

1 for j = 2 to A.length

2   key = A[j]

3   // A[j]를 정렬된 배열 A[1.. j - 1]에 삽입한다

4   i = j - 1

5   while i > 0 그리고 A[i] > key

6       A[i + 1] = a[i]

7       i = i - 1

8   A[i + 1] = key

```

  

### 루프 :불변성과 삽입 정렬의 타당성

  

```

1-8의 부분 배열 A[1..j-1]은 원래 A[1..j-1] 원소지만 for 루프가 반복을

시작할 때마다 정렬된 순서로 구성된다.

```

  

초기 조건 : 루프가 첫 번째 반복을 시작하기 전에 루프 불변성이 참이어야 한다.

  

유지 조건 : 루프의 반복이 시작되기 전에 루프 불변성이 참이었다면 다음 반복이 시작되기 전까지도 계속 참이어야 한다.

  

종료 조건 : 루프가 종료될 때 그 불변성이 알고리즘의 타당성을 보이는 데 도움이 될 유용한 특성을 가져야 한다.

  

#### 삽입 정렬 알고리즘에서 이런 특성이 과연 어떻게 만족하는지 확인하면

  

초기 조건 : 먼저 INSORTION_SORT의 루프가 시작되기 전(j = 2) 루프 불변성이 성립하는지 확인하면 된다.

이 때 부분 배열 A[1 ... j-1]은 한 개의 원소로 구성되는데 이 배열은 정렬되어 있다고 볼 수 있다. 따라서 반복 시작 전에 루프 불변성이 성립한다.

  

유지 조건 : 매 반복 시 루프 불변성이 유지되는지를 살펴 본다.

  

종료 조건 : 마지막으로 루프가 종료되었을 때 어떤 상황이 발생하는지를 확인해야 한다.

삽입 정렬의 경우 for 루프는 j가 A.length = n보다 커질 때(j = n + 1) 종료 된다. 유지 조건에 따라 A[1 ... n]은 같은 원소로 구성되어 있지만 정렬된 순서로 저장됨을 알 수 있다. A[1 ... n]이 전체 배열이므로 배열 전체가 정렬되었으며 따라서 알고리즘이 타당함을 말할 수 있다.

  
  

#### 연습문제

  

## 2.2 알고리즘의 분석

  

알고리즘의 분석은 그 알고리즘을 실행하는 데 필요한 자원을 예측하는 것을 의미 한다. 대부분의 경우에 측정 대상은 계산 시간이다.

  

### 삽입 정렬의 분석

  

입력 크기에 대한 가장 정확한 개념은 주어진 문제에 따라 다르다. 정렬이나 이산 푸리에 변환 계산과 같은 입력이 많은 문제에서 가장 자연스러운 척도는 입력 항목의 개수이다.

  

어떤 입력에 대한 알고리즘의 수행시간은 기본 연산 개수 또는 실행된 단계의 횟수를 말한다.

  

먼저 INSERTION-SORT 프로시저를 각 명령문의 실행에 따른 시간 비용과 실행 횟수를 먼저 고려해 살펴본다. n = A.length 일때 t[j]를 j = 2, 3, ..., n인 각 경우에 대해 5행에서 while 루프의 검사가 실행되는 횟수라고 하자. for나 while 루프가 일반적인 방법으로 종료된다고 하면 검사는 그 루프의 바디 부분과 한번 더 실행된다.

  

```

INSERTION_SORT( A ) cost times

1 for j = 2 to A.length

2   key = A[j]

3   // A[j]를 정렬된 배열 A[1.. j - 1]에 삽입한다

4   i = j - 1

5   while i > 0 그리고 A[i] > key

6       A[i + 1] = a[i]

7       i = i - 1

8   A[i + 1] = key

```

  

line 1 cost ![](https://latex.codecogs.com/gif.latex?c_1) times ![](https://latex.codecogs.com/png.latex?n)

line 2 cost ![](https://latex.codecogs.com/gif.latex?c_2) times ![](https://latex.codecogs.com/gif.latex?n-1)

line 3 cost ![](https://latex.codecogs.com/gif.latex?0) times ![](https://latex.codecogs.com/png.latex?n-1)

line 4 cost ![](https://latex.codecogs.com/gif.latex?c_4) times ![](https://latex.codecogs.com/png.latex?n-1)

line 5 cost ![](https://latex.codecogs.com/gif.latex?c_5) times ![](https://latex.codecogs.com/png.latex?\sum_{j=2}^{n}t_j)

line 6 cost ![](https://latex.codecogs.com/gif.latex?c_6) times ![](https://latex.codecogs.com/png.latex?\sum_{j=2}^{n}(t_j-1))

line 7 cost ![](https://latex.codecogs.com/gif.latex?c_7) times ![](https://latex.codecogs.com/png.latex?\sum_{j=2}^{n}(t_j-1))

line 8 cost ![](https://latex.codecogs.com/gif.latex?c_8) times ![](https://latex.codecogs.com/png.latex?n-1)

> **Note:** **값의 체크 등의 예외처리는** 위 설명처럼 하지 않습니다

알고리즘의 수행시간은 각 명령문 수행시간의 합이다. 즉, 수행시간 * 가격 만큼 기여하게 된다. 

![](https://latex.codecogs.com/gif.latex?T%28n%29%20%3D%20c_1n%20&plus;%20c_2%28n-1%29%20&plus;%20c_4%28n%20-%201%29%20&plus;%20c_5sum_%7Bj%3D2%7D%5E%7Bn%7Dt_j%20&plus;%20c_6sum_%7Bj%3D2%7D%5E%7Bn%7D%28t_j-1%29%20&plus;%20c_7sum_%7Bj%3D2%7D%5E%7Bn%7D%28t_j-1%29%20&plus;%20c_8%28n-1%29)

입력의 크기가 정해진 경우라도 어떤 입력이 주어지느냐에 따라 알고리즘의 수행 시간은 변한다. 

예를 들어서 INSERTION-SORT에서 최선의 상황은 배열이 이미 정렬된 경우다 그러면 j = 2, 3, ..., n의 각 경우에 대해
5행에서 A[i] <= Key가 된다 따라서 최선의 상황은 j = 2, 3, ..., n에 대해 수행시간은 다음과 같게 된다

![](https://latex.codecogs.com/gif.latex?T%28n%29%20%3D%20c_1n%20&plus;%20c_2%28n-1%29%20&plus;%20c_4%28n-1%29%20&plus;%20c_5%28n-1%29%20&plus;%20c_8%28n-1%29)

![](https://latex.codecogs.com/gif.latex?%3D%20%28c_1%20&plus;%20c_2%20&plus;%20c_4%20&plus;%20c_5%20&plus;%20c_8%29n%20-%20%28c_2%20&plus;%20c_4%20&plus;%20c_5%20&plus;%20c_8%29)


이 수행시간은 명령문의 비용에 의존하는 상수 a, b에 대한 an + b로 표현할 수 있다 즉, n에 관한 **선형 함수**가 된다.

배열이 역순으로, 즉 감소하는 순서로 정렬된 경우는 최악의 상황이다. 이 경우 각 A[j]를 정렬된 부분 배열 A[1...j-1]과 전부 비교해야 되므로 

![](https://latex.codecogs.com/gif.latex?%5Csum_%7Bj%3D2%7D%5E%7Bn%7Dj%3D%5Cfrac%7Bn%28n&plus;1%29%7D%7B2%7D-1)

최악의 경우 INSERTION-SORT의 수행시간은 다음이 된다.

![](https://latex.codecogs.com/gif.latex?T%28n%29%20%3D%20c_1n&plus;c_2%28n-1%29&plus;c_4%28n-1%29&plus;c_5%28%5Cfrac%7Bn%28n&plus;1%29%7D%7B2%7D-1%29&plus;c_6%28%5Cfrac%7Bn%28n-1%29%7D%7B2%7D%29&plus;c_7%28%5Cfrac%7Bn%28n-1%29%7D%7B2%7D%29&plus;c_8%28n-1%29)

![](https://latex.codecogs.com/gif.latex?%3D%28%5Cfrac%7Bc_5%7D%7B2%7D&plus;%5Cfrac%7Bc_6%7D%7B2%7D&plus;%5Cfrac%7Bc_7%7D%7B2%7D%29&plus;%28c_1&plus;c_2&plus;c_4&plus;%5Cfrac%7Bc_5%7D%7B2%7D-%5Cfrac%7Bc_6%7D%7B2%7D-%5Cfrac%7Bc_7%7D%7B2%7D&plus;c_8%29n-%28c_2&plus;c_4&plus;c_5&plus;c_8%29)


결국 "최악의 경우" 수행시간을 ![](https://latex.codecogs.com/gif.latex?an%5E2&plus;bn&plus;c)로 표현할 수 있으며 이때 상수 a, b, c는 명령문의 비용 ci에 의해 결장된다. 다시 말해 수행시간은 n에 관한 이차식이다.


### 최악의 경우와 평균적인 경우의 분석

>  알고리즘에서 최악의 경우 수행시간이 모든 입력의 수행시간에 대한 상한이 된다. 이를 알게 되면 해당 알고리즘이 이 시간보다 오래 걸리지 않음을 확신할 수 있다.

>  어떤 알고리즘은 최악의 경우가 상당히 빈번히 발생할 수 있다.

>  "평균적인 경우"가 최악의 경우만큼 거의 좋지 못한 상황일 때가 종종 있다.


반면 어떤 경우에는 **평균 수행시간** 이 중요하다. 여러 알고리즘에서 적용할 **확률적 분석** 기법을 살펴보게 되면, 수행시간의 평균값을 구할 수 있다.


### 증가 차수

각 명령문의 실제 비용을 무시하고 대신 상수 ci로 표현했다. 하지만 이런 상수도 식을 필요 이상으로 복잡하게 한다. 최악의 경우 수행시간은 명령문의 비용 ci로 표현되는 상수 a, b, c에 대해 ![](https://latex.codecogs.com/gif.latex?an%5E2&plus;bn&plus;c) 로 표현되는 것으로 충분하다.

좀 더 단순하게 추상화하여 수행시간의 **증가 비율** 또는 **증가 차수** 를 이용할 수 있는데, 이는 정말 중요하다. 식에서 충분히 큰 n에 대해 차수가 낮은 항이 상대적으로 덜 중요하므로 차수가 가장 높은 항만 고려할 것이다.



## 2.3 알고리즘의 설계

### 2.3.1 분할정복 접근법

 **재귀적** 구조를 가진 유용한 알고리즘이 많다. 이 알고리즘에서는 주어진 문제를 풀기 위해 자기 자신을 여러 번 호출함으로써 밀접하게 연관된 부분 문제를 다룬다. 이런 알고리즘들은 전형적으로 **분할정복** 접근법을 따른다.

 분할정복은 재귀 호출을 하는 각 단에서 다음 세 가지 단계로 구성된다.

  >  **분할 :** 현재의 문제를 같은 문제를 다루는 다수의 부분 문제로 분할한다.

  >  **정복 :** 부분 문제를 재귀적으로 풀어서 정복한다. 부분 문제의 크기가 충분히 작으면 직접적인 방법으로 푼다.

  >  **결합 :** 부분 문제의 해를 결합하여 원래의 문제의 해가 되도록 만든다.


 **병합 정렬(Merge Sort)** 는 분할정복 기법을 아주 잘 이용한다. 직관적으로 설명하면 다음과 같다.

  >  **분할 :** 정렬할 n개 원소 배열을 n/2개씩 부분 수열 두 개로 분할한다.

  >  **정복 :** 병합 정렬을 이용해 두 부분 배열을 재귀적으로 정렬한다.

  >  **결합 :** 정렬된 두 개의 부분 배열을 병합해 정렬된 배열 하나로 만든다.



  ```

MERGE( A, p, q, r ) 

1 n1 = q - p + 1

2 n2 = r - q

3 배열 L[1 ... n1 + 1]과 R[1 ... n2 + 1]을 생성한다

4 for i = 1 to n1

5   L[i] = A[p + i - 1]

6 for j = 1 to n2

7   R[j] = A[q + j]

8 L[n1 + 1] = number.Max

9 R[n2 + 1] = number.Max

10 i = 1

11 j = 1

12 for k = p to r

13  if L[i] <= R[j]

14      A[k] = L[i]

15      i = i + 1

16  else A[k] = R[j]

17      j = j + 1

```

루프 불변성을 12-17행의 for 루프가 처음 반복하기 전에 만족하는지, 루프의 매 반복 시 불변식이 유지되는지, 그리고 루프가 종료될 때 타당성을 설명할 유용한 어떤 특성이 있는지를 증명해야 한다.

  >  **초기조건 :** 루프의 첫 번째 반복이 시작되기 직전에는 k = p이므로 부분 배열 A[p ... k-1]은 비어 있다. 이 빈 배열은 L과 R에서 가장 작은 k - p = 0개의 원소를 가지고 있고 i = j = 1이므로 L[i]와 R[j]는 각각 A로 복사되지 않은 원소 중 가장 작은 원소를 가지고 있다.

  >  **유지조건 :** 각 반복 시 루프 불변성이 유지됨을 보이기 위해 먼저 L[i] <= R[j]의 경우를 살펴보자. L[i]는 아직 A로 복사되지 않은 가장 작은 원소다. A[p ... k-1]은 k - p개의 가장 작은 원소를 가지고 있으므로 14행에서 L[i]를 A[k]로 복사하면 된다. k(for 루프의 갱신에서)와 i(15행에서)를 증가시키는 것은 다음 반복에서의 루프 불변성을 확립한다. L[i] > R[j]라면 비슷하게 16-17행에서 루프 불변성을 유지하기 위한 적절한 작업을 한다.

  >  **종료조건 :** 종료될 때는 k = r + 1이다. 루프 불변성에 의해 부분 배열 A[p ... k - 1], 즉 A[p ... r]은 L[1 ... n1 + 1]과 R[1 ... n2 + 1]에서 가장 작은 k - p = r - p + 1개의 원소를 정렬된 순서로 저장한다. 배열 L과 R은 모두 합쳐 n1 + n2 + 2 = r - p + 3개의 원소를 가지고 있따. 가장 큰 두 개의 원소를 제외하고 모두 A로 복사되는데, 두 원소는 경계 카드다.

    ```

MERGE-SORT( A, p, r ) 

1 if p < r

2   q = ( p + r ) / 2

3   MERGE-SORT( A, p, q )

4   MERGE-SORT( A, q + 1, r )

5   MERGE( A, p, q, r )


```

### 2.3.2 분할정복 알고리즘의 분석

크기가 n/b인 부분 문제에 T(n/b) 시간이 걸렸다면 a개의 문제를 해결 하는 데는 aT(n/b)의 시간이 걸린다. 문제를 분할하는 데 D(n) 시간이 걸린다면, 다음과 같은 식을 얻을 수 있다.

![](https://latex.codecogs.com/gif.latex?T%28n%29%3Dif%20n%20%3C%3D%20c%20x%20%5Crightarrow%20%5CTheta%20%281%29%20otherwise%5Crightarrow%20aT%28n/b%29%20&plus;%20D%28n%29%20&plus;%20C%28n%29)

#### 병합 정렬의 분석

  >  **분할 :** 분할 단계는 부분 배열의 중간 위치를 계싼하므로 상수 시간이 거린다. 즉 D(n) = O(1)이다.

  >  **정복 :** 두 개의 부분 문제를 재귀적으로 푸는데, 각 부분 문제는 크기가 n/2이 걸리므로 2T(n/2) 수행시간이 걸린다.

  >  **결합 :** 이미 설명했듯이 n개 원소에 대해 MERGE 프로시저는 O(n) 시간이 걸린다. 즉, C(n) = O(n)이다.

  