# 2. 시작하기

## 2.1 삽입 정렬

입력 : `n개 수들의 수열` <a1, a2, ....., an>

출력 : `a'1 <= a'2 <= ... <= a'n을 만족하는 입력 순열`(재배치)

의사코드는 일반적으로 소프트웨어 공학 관점의 문제를 고려하지 않는다. 
그래서 데이터 추상화, 모듈화, 오류 처리 등의 문제가 종종 무시되는데, 이는 알고리즘의 본질을 좀 더 간결하고 분명하게 전달하기 위해서다.

```
INSERTION_SORT( A )
1   for j = 2 to A.length
2       key = A[j]
3       // A[j]를 정렬된 배열 A[1.. j - 1]에 삽입한다
4       i = j - 1
5       while i > 0 그리고 A[i] > key
6           A[i + 1] = a[i]
7           i = i - 1
8       A[i + 1] = key
```

### 루프 :불변성과 삽입 정렬의 타당성

```
1-8의 부분 배열 A[1..j-1]은 원래 A[1..j-1] 원소지만 for 루프가 반복을
시작할 때마다 정렬된 순서로 구성된다.
```

초기 조건 : 루프가 첫 번째 반복을 시작하기 전에 루프 불변성이 참이어야 한다.

유지 조건 : 루프의 반복이 시작되기 전에 루프 불변성이 참이었다면 다음 반복이 시작되기 전까지도 계속 참이어야 한다.

종료 조건 : 루프가 종료될 때 그 불변성이 알고리즘의 타당성을 보이는 데 도움이 될 유용한 특성을 가져야 한다.

#### 삽입 정렬 알고리즘에서 이런 특성이 과연 어떻게 만족하는지 확인하면

초기 조건 : 먼저 INSORTION_SORT의 루프가 시작되기 전(j = 2) 루프 불변성이 성립하는지 확인하면 된다. 
이 때 부분 배열 A[1 ... j-1]은 한 개의 원소로 구성되는데 이 배열은 정렬되어 있다고 볼 수 있다. 따라서 반복 시작 전에 루프 불변성이 성립한다.

유지 조건 : 매 반복 시 루프 불변성이 유지되는지를 살펴 본다. 

종료 조건 : 마지막으로 루프가 종료되었을 때 어떤 상황이 발생하는지를 확인해야 한다. 
삽입 정렬의 경우 for 루프는 j가 A.length = n보다 커질 때(j = n + 1) 종료 된다. 유지 조건에 따라 A[1 ... n]은 같은 원소로 구성되어 있지만 정렬된 순서로 저장됨을 알 수 있다. A[1 ... n]이 전체 배열이므로 배열 전체가 정렬되었으며 따라서 알고리즘이 타당함을 말할 수 있다.


#### 연습문제